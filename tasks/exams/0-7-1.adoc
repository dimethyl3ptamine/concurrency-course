.Задача 1:
 Реализовать структуру данных Treiber Stack. Это неблокирующий многопоточный стэк. По реализации похоже на очередь, но работа идёт по принципу LIFO.

---

.Задача 2:

 На сервис приходят данные из двух очередей:
 - srcX -> x1, x2, x3, ...
 - srcY -> y1, y2, y3, ...
 Источники независимые, данные приходят по порядку, но неравномерно.
 Нужно вычислить сумму значений с одним индексом и отправить результат в очередь. В очередь должны попадать значения по порядку: x1+y1, x2+y2, x3+y3 и тд.
 Нигде не должно быть блокировок.

---

.Задача 3:

 В нашей игре есть такая механика как кланы, иначе говоря скопления игроков объединенные общей целью. У каждого клана есть своя казна с золотом. Есть различные способы пополнения казны клана. Можно выполнять задания, сражаться на арене, просто пополнить казну из своего кармана и т.д. И конечно же мы следим за всеми действиями, чтобы в случае чего служба поддержки могла как-то отвечать на вопросы пользователей в случае какого-то недопонимания.
 Дана иерархия классов:
 // Упрощенный объект клана
 public class Clan {
     private long id;     // id клана
     private String name; // имя клана
     private int gold;    // текущее количество золота в казне клана
 }
 // Есть сервис, посвященный кланам.
 // Да это выглядит как 'репозиторий'.
 // Но это сервис, просто все остальные методы не нужны для примера
 public interface ClanService {
     Clan get(long clanId);
 }
 // Так же у нас есть ряд сервисов похожих на эти.
 // Их суть в том, что они добавляют(или уменьшают) золото в казне клана
 public class UserAddGoldService { // пользователь добавляет золото из собственного кармана
     private final ClanService clans;
     public void addGoldToClan(long userId, long clanId, int gold) {
         Clan clan = clans.getClan(clanId);
         // clan.[gold] += gold;
         // как-то сохранить изменения
     }
 }
 // Еще один такой сервис
 public class TaskService { // какой-то сервис с заданиями
     private final ClanService clans;
     void completeTask(long clanId, long taskId) {
         // ...
         // if (success)
         {
             Clan clan = clans.getClan(clanId);
             // clan.[gold] += gold;
             // как-то сохранить изменения
         }
     }
 }
 Данная структура лишь пример, и вы можете менять её на свое усмотрение.
 Что нужно сделать:
 - Реализовать логику добавления/уменьшения золота в клан, при этом предусмотреть, что золото может зачислиться из сотни разных потоков в один момент. Разными пользователями по разной причине.
 - Реализовать отслеживание разных действий начисления золота, чтобы служба поддержки смогла идентифицировать когда и по какой причине в казне изменилось количества золота, сколько было, сколько стало и т.д.

---

Задача 4

 Есть внешний сервис, который обрабатывает некие абстрактные объекты батчами. Данный сервис может обрабатывать только определенное количество элементов в заданный временной интервал. При превышении ограничения сервис блокирует последующую обработку на долгое время.
 Дальше возможны варианты:
 Вариант 1: реализовать сервис с подобной функциональностью
 Вариант 2: реализовать клиента к данному сервису, который позволит обрабатывать максимально возможное количество объектов без блокировки.
 Определение сервиса:
 public class MTTask {
     public record Task() {}
     public record Batch(List<Task> tasks) {}
     public static class Service {
         public static final int DURATION_IN_MILLIS = 2*60*1000;
         public static final int TASK_LIMIT = 50;
         public void process(Batch batch) {
         }
     }
 }